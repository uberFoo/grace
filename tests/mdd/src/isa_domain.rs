//! Isa Relationship Domain
//!
//! This file was generated by: `sarzak new "Isa Relationship"`.
use uuid::{uuid, Uuid};

pub mod store;
pub mod types;

pub use store::ObjectStore;
pub use types::*;

// Isa Relationship
pub const UUID_NS: Uuid = uuid!("fdd6c56b-f3fb-59ba-b387-31dd1ff762ea");

#[cfg(test)]
mod tests {
    //! I'm not sure what to test here. Making macros to traverse the Isa
    //! relationship is just weird. I don't think it makes any sense, but
    //! if it does in the future, I'll come back to it. For now, this
    //! half-baked attempt at a test. I hate deleting stuff. Bits are cheap.
    //!
    //! Update â€” so maybe this is an enum test? I don't currently do enums,
    //! and this should be creating enums.
    use super::*;

    #[test]
    fn test_r1() {
        // let mut store = ObjectStore::new();
        // What's the point of navigating this? So, let's agree that supertype
        // to subtype navigation is trivial.
        //
        // > Care to explain?
        //
        // I have no idea what I _was_ thinking, but if you have a supertype it's
        // easy enough to get the subtype: `super.id()` will do it. But you have
        // no idea which subtype you are holding. You'd need to match on self
        // to really get it done.
        //
        // Let's go the other way. This is
        // opposite to the "owned property" of e.g., objects and attributes.
        //
        // > The other way makes no sense.
        //
        // For one what would be the point? As it is supertypes are barren wastelands
        // when it comes to attributes. They don't even have a real id. Their id
        // is that of their current subtype.
        //
        // But beyond that, there is no supertype. It's just a UUID that points at
        // a subtype. So there. No point going forward, no point going backward.
        //
        // Still, we can test the store, I suppose.
        //
    }
}
